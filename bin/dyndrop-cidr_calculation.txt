192 11000000
255 11111111

183.192.0.0-183.255.255.255
183.192.0.0/(32-16-6) /10

10110111 11000000 00000000 00000000
10110111 11111111 11111111 11111111
00000000 00111111 11111111 11111111 xor
zeros: 1*8+2 = 10
183.192/10

192.168.1.0-192.168.1.255
11000000 10101000 00000001 00000000
11000000 10101000 00000001 11111111
00000000 00000000 00000000 11111111 xor
zeros: 3*8 = 24
192.168.1/24

114.67.64.0-114.67.255.255
01110010 01000011 01000000 00000000
01110010 01000011 11111111 11111111
00000000 00000000 10111111 11111111 xor
          1          2          3
12345678 90123456 78901234 56789012

114.67.64.0/18
114.67.127.0/17
114.67.064 01110010 01000011 01000000
114.67.127 01110010 01000011 01111111

64.0-255.255
01000000 00000000
11111111 11111111
10111111 11111111

93.115.7.0-93.115.7.127
0.0.0.0-0.0.0.127
00000000
01111111
01111111 xor
zeros: 8*3+1 = 25
93.115.7.0/25

t={}
(0..255).each { |v| t[v]="%08b"%v }
t[144]="10010000"
t[192].to_i(2) = 192
t[144]="10010000"

EXAMPLES that fails on simple cidr test, two overlapping cidrs in range.

Getting cidr for range 58.56.0.0-58.59.127.255
00111010 00111000 00000000 00000000 58.56.0.0
00111010 00111011 01111111 11111111 58.59.127.255
00000000 00000011 01111111 11111111 xor
12345678 90123456 78901234 56789012
          1          2          3

cidr 58.56.0.0/15 00111010 00111000
cidr 58.58.0.0/16 00111010 00111010
cidr 58.59.0.0/17 00111010 00111011

ip0 00111010 00111000 00000000 00000000 58.56.0.0
ip1 00111010 00111011 01111111 11111111 58.59.127.255
xor 00000000 00000011 01111111 11111111 15th bit differs, 58.56.0.0/15
    12345678 90123456 78901234 56789012
              1          2          3

For the next ip0, flip the 15th bit of the last ip0, and compare to ip1 again

ip0 00111010 00111010 00000000 00000000 58.58.0.0 flip the 15th bit (from the left)
ip1 00111010 00111011 01111111 11111111 58.59.127.255
    00000000 00000001 01111111 11111111 16th bit differs, so 58.58.0.0/16
    12345678 90123456 78901234 56789012
              1          2          3

For the next ip0, flip the 16th bit of the last ip0, and compare to ip1 again

ip0 00111010 00111011 00000000 00000000 58.59.0.0 flip the 16th bit of the last src
ip1 00111010 00111011 01111111 11111111 58.59.127.255
    00000000 00000000 01111111 11111111 17 bits clean, so 58.59.0.0/17

No zeros after the first 1 bit, so bitmask length is 17, ip0/17

Done

Getting cidr for range 220.160.0.0-220.162.255.255
11011100 10100000 00000000 00000000
11011100 10100010 11111111 11111111
00000000 00000010 11111111 11111111 xor
12345678 90123456 78901234 56789012
          1          2          3
220.160.0.0/14 cidr false

Searching blacklist table for 220.161.34.199 in 220.160.0.0/15
Searching blacklist table for 220.161.34.199 in 220.162.0.0/16


> 220.160.0.0-220.162.255.255
220.160.0.0-220.162.255.255

Getting cidr for range 220.160.0.0-220.162.255.255
11011100 10100000 00000000 00000000
11011100 10100010 11111111 11111111
00000000 00000010 11111111 11111111 xor
12345678 90123456 78901234 56789012
          1          2          3
220.160.0.0/14 cidr false

Getting range for 220.160.0.0-220.162.255.255
Getting merged cidr array
Drop cidr 220.160.0.0/15? [y/n] y
Dropping cidr=220.160.0.0/15
220.160.0.0/15 Blacklisted
Drop cidr 220.162.0.0/16? [y/n] y
Dropping cidr=220.162.0.0/16
220.162.0.0/16 Blacklisted

ip0 11011100 10100000 00000000 00000000 220.160.000.000
ip1 11011100 10100010 11111111 11111111 220.162.255.255
xor 00000000 00000010 11111111 11111111 15th bit differs, so 220.160.0.0/15
    12345678 90123456 78901234 56789012
              1          2          3

Flip the 15th bit of the last ip0

ip0 11011100 10100010 00000000 00000000 220.162.000.000
ip1 11011100 10100010 11111111 11111111 220.162.255.255
xor 00000000 00000000 11111111 11111111 16 bits clean, so 220.162.0.0/16
    12345678 90123456 78901234 56789012
              1          2          3
